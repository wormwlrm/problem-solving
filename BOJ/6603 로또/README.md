## 6603 로또

<https://www.acmicpc.net/problem/6603>

## 내가 생각한 방법

- 백트래킹 방법으로 모든 배열의 원소를 순환하기로 한다
- 방문한 노드를 `deque` 로 저장한다
- 유망한 노드인지를 어떻게 판단할까?

  - 우선 입력이 오름차순으로 정렬되어있고, 순서대로 넣는다는 기준이 있다
  - 따라서 **특정 인덱스의 원소를 넣었을 때, 이미 방문한 원소 배열보다 방문할 수 있는 원소 값의 갯수가 커야 한다**
    - ex) `[1, 2, 3, 4, 5, 6, 7]` 배열을 순서대로 방문한다고 가정하자
    - `[1]`을 방문한 상태에서는 사실 `[4, 5, 6, 7]` 은 방문할 필요가 없다
    - 왜냐하면 4의 경우 `[1, 4, 5, 6, 7]` 처럼 해당 원소의 오른쪽을 모두 방문했을 때에도 6개를 만족시키지 못하기 때문
  - 그것을 아래의 방식으로 생각해 냄

    ```python
    left_count = max_depth - len(visited)
    right_count = count - coming

    return left_count <= right_count
    ```
